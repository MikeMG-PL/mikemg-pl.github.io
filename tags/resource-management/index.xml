













    
        
    

    
        
    







    

    






<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"  xml:lang="en-us"  xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        
            

            
                
            

            
                <link href="https://mikegalinski.com/tags/resource-management/" rel="self" type="text/html"/>
            
        
            

            

            
                <link href="https://mikegalinski.com/tags/resource-management/index.xml" rel="alternate" type="application/rss+xml"/>
            
        

        

        

        <description></description>

        
            <language>en-us</language>
        

        
            <lastBuildDate>2024-10-04 16:58:35 &#43;0200 CEST</lastBuildDate>
        

        <link>https://mikegalinski.com/tags/resource-management/</link>

        

        <title>Resource Management · Tags · </title>

        

        
            <item>
                
                
                
                
                
                
                

                

                

                

                

                
                

                

                

                
                    <description><![CDATA[<style>

:target:before {
  content: ''
  display: block;
  height: 100px; /* Adjust offset as needed */
  margin-top: -100px; /* Negative value equal to height */
  visibility: hidden;
}

html {
  scroll-behavior: smooth; /* Enable smooth scrolling behavior */
}

</style>
<p>Resource management in game engines is a wide term. It ranges from handling freshly exported assets to managing assets loaded into memory, in a specific form for particular engine modules. In this article I describe the most basic form of <strong>runtime resource management</strong> – based on sharing a resource loaded only once into memory.</p>
<h2 id="background">Background</h2>
<p>I present this topic in the context of a <a href="/portfolio/guiding-light/"><strong>simple game engine I coworked on</strong></a>, written in <strong>4 months</strong>, in modern C++ and DirectX 11 for courses conducted by <a href="https://p.lodz.pl/en">Lodz University of Technology</a>. In this post I want to guide <strong>students and beginners in engine programming</strong> trying to create their first game engine, drawing from my experience with this project.</p>
<h2 id="why-basic-resource-management-is-important">Why Basic Resource Management Is Important</h2>
<p><strong>It&rsquo;s the memory cost, CPU efficiency, and loading times</strong>. Let&rsquo;s recall your first graphics programming project. Maybe it was a graphics programming course at your university or you were just playing with <a href="https://learnopengl.com">learnopengl.com</a>, or something else. <strong>Did you pay much attention to how often are the assets loaded?</strong></p>
<p>Let&rsquo;s investigate a scene having <strong>20 identical models (with multiple meshes)</strong> and <strong>20 identical textures</strong> of the &ldquo;level completed&rdquo; panel. <strong>How many times are these assets loaded?</strong></p>
<center>





















  
  
  


  
  
    
    
      
    

    


    
    


    
    
    
    
    
    
    


    
    
      
      

      


      

      
      
        
        
        
      
      
      
      

    
    

    
    
      
      
          <img
            title=""
            loading="lazy"
            decoding="async"
            class="img img-fluid "
            width="711"
            height="400"
            src="/images/posts/post-3/case_hubd87f6e866213ecbad592fd756a27da6_489094_711x400_resize_q100_h2_lanczos_3.webp"
            alt=""
            onerror="this.onerror='null';this.src='\/images\/posts\/post-3\/case_hubd87f6e866213ecbad592fd756a27da6_489094_711x400_resize_q100_lanczos_3.png'" />
      
    

  
  






  <script>
    window.addEventListener("load", (e) => {
      const lightbox = GLightbox();
    });
  </script>


</center>



  



<div class="notice info">
  <div class="notice-head"><svg
        width="20"
        height="20"
        viewBox="0 0 18 20"
        fill="none"
        xmlns="http://www.w3.org/2000/svg">
        <path
          d="M9.16109 0.993016C9.97971 1.03952 10.6611 1.42989 11.0721 2.22339L17.7981 15.8014C18.4502 17.1739 17.4403 19.0208 15.7832 19.0474H2.23859C0.730337 19.0234 -0.507163 17.3108 0.231587 15.7864L7.08321 2.20877C7.21146 1.96502 7.26996 1.89452 7.38059 1.76664C7.82534 1.25102 8.31171 0.975016 9.16109 0.993016ZM9.05046 2.49189C8.79284 2.50464 8.55696 2.64902 8.42834 2.87327C6.06134 7.36539 3.77946 11.9036 1.56546 16.4734C1.36071 16.9328 1.71209 17.5223 2.22621 17.547C6.74871 17.6201 11.2731 17.6201 15.7956 17.547C16.2925 17.523 16.666 16.953 16.459 16.4783C14.2866 11.9093 12.0471 7.37102 9.72171 2.87814C9.58446 2.63402 9.38309 2.48739 9.05046 2.49189Z"
          fill="currentColor" />
        <path
          d="M9.61323 13.2153H8.35773L8.21973 7.04688H9.75723L9.61323 13.2153ZM8.17773 15.1015C8.17773 14.8731 8.25161 14.6841 8.39973 14.5338C8.54823 14.3838 8.75036 14.3084 9.00648 14.3084C9.26298 14.3084 9.46511 14.3838 9.61323 14.5338C9.76136 14.6841 9.83561 14.8731 9.83561 15.1015C9.83561 15.3216 9.76323 15.5057 9.61923 15.6539C9.47486 15.802 9.27086 15.8762 9.00648 15.8762C8.74211 15.8762 8.53811 15.802 8.39373 15.6539C8.24973 15.5057 8.17773 15.3216 8.17773 15.1015Z"
          fill="currentColor" />
      </svg><p>Info</p>
  </div>
  <div class="notice-body"><p><strong>Without</strong> runtime resource manager, the same model and texture will be loaded into memory <strong>20 times – for each instance</strong>.<br>
<strong>With</strong> runtime resource manager, the same model and texture will be loaded into memory <strong>only once – with the first instance</strong>.</p></div>
</div>

<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">❌ without runtime resource manager</th>
<th style="text-align:center">✅ with runtime resource manager</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>memory cost</strong></td>
<td style="text-align:center">




















  
  
  


  
  
    
    
      
    

    


    
    


    
    
    
    
    
    
    


    
    
      
      

      


      

      
      
        
        
        
      
      
      
      

    
    

    
    
      
      
          <img
            title=""
            loading="lazy"
            decoding="async"
            class="img img-fluid "
            width="640"
            height="360"
            src="/images/posts/post-3/no_rm_memory_hub8e2a5824e4de038c519f53f8db8130c_23176_640x360_resize_q100_h2_lanczos_3.webp"
            alt=""
            onerror="this.onerror='null';this.src='\/images\/posts\/post-3\/no_rm_memory_hub8e2a5824e4de038c519f53f8db8130c_23176_640x360_resize_q100_lanczos_3.png'" />
      
    

  
  






<br>1.6 GB</td>
<td style="text-align:center">




















  
  
  


  
  
    
    
      
    

    


    
    


    
    
    
    
    
    
    


    
    
      
      

      


      

      
      
        
        
        
      
      
      
      

    
    

    
    
      
      
          <img
            title=""
            loading="lazy"
            decoding="async"
            class="img img-fluid "
            width="640"
            height="360"
            src="/images/posts/post-3/rm_memory_hu848d484aaa2ce7eb459f8b4c893c28c8_18763_640x360_resize_q100_h2_lanczos_3.webp"
            alt=""
            onerror="this.onerror='null';this.src='\/images\/posts\/post-3\/rm_memory_hu848d484aaa2ce7eb459f8b4c893c28c8_18763_640x360_resize_q100_lanczos_3.png'" />
      
    

  
  






<br>678 MB</td>
</tr>
<tr>
<td style="text-align:center"><strong>peak CPU %<br>while loading</strong></td>
<td style="text-align:center">




















  
  
  


  
  
    
    
      
    

    


    
    


    
    
    
    
    
    
    


    
    
      
      

      


      

      
      
        
        
        
      
      
      
      

    
    

    
    
      
      
          <img
            title=""
            loading="lazy"
            decoding="async"
            class="img img-fluid "
            width="640"
            height="360"
            src="/images/posts/post-3/no_rm_percent_hub8c90133388229b6dbbe09c64527b3bf_27433_640x360_resize_q100_h2_lanczos_3.webp"
            alt=""
            onerror="this.onerror='null';this.src='\/images\/posts\/post-3\/no_rm_percent_hub8c90133388229b6dbbe09c64527b3bf_27433_640x360_resize_q100_lanczos_3.png'" />
      
    

  
  






<br>21%</td>
<td style="text-align:center">




















  
  
  


  
  
    
    
      
    

    


    
    


    
    
    
    
    
    
    


    
    
      
      

      


      

      
      
        
        
        
      
      
      
      

    
    

    
    
      
      
          <img
            title=""
            loading="lazy"
            decoding="async"
            class="img img-fluid "
            width="640"
            height="360"
            src="/images/posts/post-3/rm_percent_hu85eeeb1c6f087cb36f37b46e5e61be94_19478_640x360_resize_q100_h2_lanczos_3.webp"
            alt=""
            onerror="this.onerror='null';this.src='\/images\/posts\/post-3\/rm_percent_hu85eeeb1c6f087cb36f37b46e5e61be94_19478_640x360_resize_q100_lanczos_3.png'" />
      
    

  
  






<br>14%</td>
</tr>
<tr>
<td style="text-align:center"><strong>load time</strong></td>
<td style="text-align:center">2.280 s</td>
<td style="text-align:center">0.645 s</td>
</tr>
</tbody>
</table>
<p>This is <strong>one of the first thing we wanted to pay attention to</strong> when transistioning our project from a small graphics programming application to a simple framework/engine. Such improvement was easy to implement for us, and it can be <strong>good enough</strong> in terms of optimizing memory and CPU efficiency in your first game engine too.</p>
<h2 id="implementation">Implementation</h2>
<p>Firstly, let&rsquo;s create a <code>ResourceManager</code> class and make it a Meyers&rsquo; Singleton. It&rsquo;s not the devil here. Singletons are often used in game engines, and having a global access to this only instance is really helpful. You also probably don&rsquo;t bother about thread-safety in you first, single-threaded, game engine.</p>
<p>In our case, we list the following types of resources: <strong>shaders, textures, and meshes</strong>.</p>



  



<div class="notice note">
  <div class="notice-head"><svg
        width="20"
        height="20"
        viewBox="0 0 20 20"
        fill="none"
        xmlns="http://www.w3.org/2000/svg">
        <path
          d="M10 9V14M10 19C5.02944 19 1 14.9706 1 10C1 5.02944 5.02944 1 10 1C14.9706 1 19 5.02944 19 10C19 14.9706 14.9706 19 10 19ZM10.0498 6V6.1L9.9502 6.1002V6H10.0498Z"
          stroke="currentColor"
          stroke-width="2"
          stroke-linecap="round"
          stroke-linejoin="round"></path>
      </svg><p>Note</p>
  </div>
  <div class="notice-body"><p>– What about sounds?<br>
– They are handled differently via <a href="https://miniaud.io">miniaudio</a> library which takes care of reference counting.</p></div>
</div>

<p>Let&rsquo;s declare methods for loading our resources. We&rsquo;re trying to make sort of a unified interface here, but you will see how those loader methods reference other subsystems and delegate loading resources to particular factory methods in different modules.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// ResourceManager.h:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>Texture<span style="color:#f92672">&gt;</span> load_texture(std<span style="color:#f92672">::</span>string <span style="color:#66d9ef">const</span><span style="color:#f92672">&amp;</span> path, TextureType <span style="color:#66d9ef">const</span> type, TextureSettings <span style="color:#66d9ef">const</span><span style="color:#f92672">&amp;</span> settings <span style="color:#f92672">=</span> {});
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>Texture<span style="color:#f92672">&gt;</span> load_cubemap(std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">const</span><span style="color:#f92672">&amp;</span> paths, TextureType <span style="color:#66d9ef">const</span> type,
</span></span><span style="display:flex;"><span>                                      TextureSettings <span style="color:#66d9ef">const</span><span style="color:#f92672">&amp;</span> settings <span style="color:#f92672">=</span> {});
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>Texture<span style="color:#f92672">&gt;</span> load_cubemap(std<span style="color:#f92672">::</span>string <span style="color:#66d9ef">const</span><span style="color:#f92672">&amp;</span> path, TextureType <span style="color:#66d9ef">const</span> type, TextureSettings <span style="color:#66d9ef">const</span><span style="color:#f92672">&amp;</span> settings <span style="color:#f92672">=</span> {});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>Shader<span style="color:#f92672">&gt;</span> load_shader(std<span style="color:#f92672">::</span>string <span style="color:#66d9ef">const</span><span style="color:#f92672">&amp;</span> compute_path);
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>Shader<span style="color:#f92672">&gt;</span> load_shader(std<span style="color:#f92672">::</span>string <span style="color:#66d9ef">const</span><span style="color:#f92672">&amp;</span> vertex_path, std<span style="color:#f92672">::</span>string <span style="color:#66d9ef">const</span><span style="color:#f92672">&amp;</span> pixel_path);
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>Shader<span style="color:#f92672">&gt;</span> load_shader(std<span style="color:#f92672">::</span>string <span style="color:#66d9ef">const</span><span style="color:#f92672">&amp;</span> vertex_path, std<span style="color:#f92672">::</span>string <span style="color:#66d9ef">const</span><span style="color:#f92672">&amp;</span> pixel_path, std<span style="color:#f92672">::</span>string <span style="color:#66d9ef">const</span><span style="color:#f92672">&amp;</span> geometry_path);
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>Shader<span style="color:#f92672">&gt;</span> load_shader(std<span style="color:#f92672">::</span>string <span style="color:#66d9ef">const</span><span style="color:#f92672">&amp;</span> vertex_path, std<span style="color:#f92672">::</span>string <span style="color:#66d9ef">const</span><span style="color:#f92672">&amp;</span> tessellation_control_path,
</span></span><span style="display:flex;"><span>                                    std<span style="color:#f92672">::</span>string <span style="color:#66d9ef">const</span><span style="color:#f92672">&amp;</span> tessellation_evaluation_path, std<span style="color:#f92672">::</span>string <span style="color:#66d9ef">const</span><span style="color:#f92672">&amp;</span> pixel_path);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>Mesh<span style="color:#f92672">&gt;</span> load_mesh(u32 <span style="color:#66d9ef">const</span> array_id, std<span style="color:#f92672">::</span>string <span style="color:#66d9ef">const</span><span style="color:#f92672">&amp;</span> name, std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Vertex<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">const</span><span style="color:#f92672">&amp;</span> vertices,
</span></span><span style="display:flex;"><span>                                std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>u32<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">const</span><span style="color:#f92672">&amp;</span> indices, std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>Texture<span style="color:#f92672">&gt;&gt;</span> <span style="color:#66d9ef">const</span><span style="color:#f92672">&amp;</span> textures,
</span></span><span style="display:flex;"><span>                                DrawType <span style="color:#66d9ef">const</span> draw_type, std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>Material<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">const</span><span style="color:#f92672">&amp;</span> material,
</span></span><span style="display:flex;"><span>                                DrawFunctionType <span style="color:#66d9ef">const</span> draw_function <span style="color:#f92672">=</span> DrawFunctionType<span style="color:#f92672">::</span>Indexed);
</span></span></code></pre></div><p>Each of these methods is responsible for loading a resource. As you can see e.g. <code>load_shader()</code> methods are overloaded, as different shaders can be loaded. Next, let&rsquo;s declare vectors that store our resources:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>Texture<span style="color:#f92672">&gt;&gt;</span> m_textures <span style="color:#f92672">=</span> {};
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>Mesh<span style="color:#f92672">&gt;&gt;</span> m_meshes <span style="color:#f92672">=</span> {};
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>Shader<span style="color:#f92672">&gt;&gt;</span> m_shaders <span style="color:#f92672">=</span> {};
</span></span></code></pre></div>


  



<div class="notice info – generating keys">
  <div class="notice-head"><svg
        width="20"
        height="20"
        viewBox="0 0 20 20"
        fill="none"
        xmlns="http://www.w3.org/2000/svg">
        <path
          d="M10 9V14M10 19C5.02944 19 1 14.9706 1 10C1 5.02944 5.02944 1 10 1C14.9706 1 19 5.02944 19 10C19 14.9706 14.9706 19 10 19ZM10.0498 6V6.1L9.9502 6.1002V6H10.0498Z"
          stroke="currentColor"
          stroke-width="2"
          stroke-linecap="round"
          stroke-linejoin="round"></path>
      </svg><p>Info – Generating Keys</p>
  </div>
  <div class="notice-body"><p>To load resources only once we need to keep track of what has already been loaded, and return a pointer to a resource instead of loading it again. We track it by <strong>generating a unique key for each resource</strong>. This &ldquo;key&rdquo; is a string in the following <code>std::unordered_map</code>. <strong>The key is tied to an index of the resource in its respective vector</strong> and it uniquely <strong>identifies where the asset comes from</strong>. We need to distinguish that <strong>a model loaded from a file <em>&ldquo;model1.gltf&rdquo;</em>  is different from a model loaded from <em>&ldquo;model2.gltf&rdquo;</em></strong>, and that <strong>when we load <em>&ldquo;model1.gltf&rdquo;</em> again, it&rsquo;s the same file that was loaded earlier</strong>, so we need to <strong>reference what&rsquo;s already loaded</strong> instead of loading it again. The key is <strong>a bridge between an asset on disk and it&rsquo;s different form in memory</strong>.</p></div>
</div>

<p>Here are the unordered maps storing <strong>keys</strong> and <strong>IDs</strong> in the respective <code>m_textures</code>/<code>m_meshes</code>/<code>m_shaders</code> vectors.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>unordered_map<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string, u16<span style="color:#f92672">&gt;</span> names_to_textures <span style="color:#f92672">=</span> {};
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>unordered_map<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string, u16<span style="color:#f92672">&gt;</span> names_to_meshes <span style="color:#f92672">=</span> {};
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>unordered_map<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string, u16<span style="color:#f92672">&gt;</span> names_to_shaders <span style="color:#f92672">=</span> {};
</span></span></code></pre></div><p><code>std::unordered_map</code> here is perfect, because generating keys for a resource manager is convenient when using strings, and <code>std::unordered_map</code> hashes the strings. It&rsquo;s good to remember for the future that comparing hashed strings is <strong>much faster</strong> than actual strings!</p>
<p>Let&rsquo;s also declare a simple method that just converts a stringstream to string, this is for convenience, and this is, in fact, generating a string key:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a6e22e">[[nodiscard]]</span> std<span style="color:#f92672">::</span>string generate_key(std<span style="color:#f92672">::</span>stringstream <span style="color:#66d9ef">const</span><span style="color:#f92672">&amp;</span> stream) <span style="color:#66d9ef">const</span>;
</span></span></code></pre></div><p>&hellip;and a method for retrieving an element from a vector. <strong>This is a template method</strong> <em>(compile time goes brrr!)</em>  but in this simple case it could be just three similar methods for each type of resource. It might look a bit ugly for you, but handling it like that is not necessarily bad. The resources are vastly different, and the more types of them you have, the harder it gets to prepare a unified approach. The nature of a resource manager itself often results in methods like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> get_from_vector(std<span style="color:#f92672">::</span>string <span style="color:#66d9ef">const</span><span style="color:#f92672">&amp;</span> key)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    i32 id <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">constexpr</span> (std<span style="color:#f92672">::</span>is_same_v<span style="color:#f92672">&lt;</span>T, Texture<span style="color:#f92672">&gt;</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">auto</span> <span style="color:#66d9ef">const</span> it <span style="color:#f92672">=</span> names_to_textures.find(key);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (it <span style="color:#f92672">!=</span> names_to_textures.end())
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            id <span style="color:#f92672">=</span> it<span style="color:#f92672">-&gt;</span>second;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> m_textures[id];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">constexpr</span> (std<span style="color:#f92672">::</span>is_same_v<span style="color:#f92672">&lt;</span>T, Mesh<span style="color:#f92672">&gt;</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">auto</span> <span style="color:#66d9ef">const</span> it <span style="color:#f92672">=</span> names_to_meshes.find(key);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (it <span style="color:#f92672">!=</span> names_to_meshes.end())
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            id <span style="color:#f92672">=</span> it<span style="color:#f92672">-&gt;</span>second;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> m_meshes[id];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">constexpr</span> (std<span style="color:#f92672">::</span>is_same_v<span style="color:#f92672">&lt;</span>T, Shader<span style="color:#f92672">&gt;</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">auto</span> <span style="color:#66d9ef">const</span> it <span style="color:#f92672">=</span> names_to_shaders.find(key);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (it <span style="color:#f92672">!=</span> names_to_shaders.end())
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            id <span style="color:#f92672">=</span> it<span style="color:#f92672">-&gt;</span>second;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> m_shaders[id];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nullptr</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>It could be automated with some autogenerated code (we have an <em>&ldquo;Engine Header Tool&rdquo;</em>  in our project used for e.g. generating (de)serialization code for components). Have a better idea for implementing it? <strong>Post it in a comment below!</strong></p>
<p>The above function, firstly, <strong>checks which type of resource are we dealing with</strong> (e.g. <code>if constexpr (std::is_same_v&lt;T, Texture&gt;)</code> is true if the given type is <code>Texture</code>) – this decides in which unordered map are we going to look for the key, and in which vector – for the resource. Then we&rsquo;re using <code>std::unordered_map::find()</code> to find the <strong>key</strong> in our unordered map. If this key is found, we <strong>return the ID of the resource</strong> paired with the key. <strong>If not, we return <code>nullptr</code>.</strong></p>
<hr>
<p>We&rsquo;re lacking the last peace of the puzzle. <strong>How do the loading methods work?</strong> And maybe at this point the idea of &ldquo;keys&rdquo; representing assets is still murky? Let me clarify:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// ResourceManager.cpp:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>Shader<span style="color:#f92672">&gt;</span> ResourceManager<span style="color:#f92672">::</span>load_shader(std<span style="color:#f92672">::</span>string <span style="color:#66d9ef">const</span><span style="color:#f92672">&amp;</span> vertex_path, std<span style="color:#f92672">::</span>string <span style="color:#66d9ef">const</span><span style="color:#f92672">&amp;</span> pixel_path)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>stringstream stream;
</span></span><span style="display:flex;"><span>    stream <span style="color:#f92672">&lt;&lt;</span> vertex_path <span style="color:#f92672">&lt;&lt;</span> pixel_path;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>string <span style="color:#66d9ef">const</span><span style="color:#f92672">&amp;</span> key <span style="color:#f92672">=</span> generate_key(stream);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> resource_ptr <span style="color:#f92672">=</span> get_from_vector<span style="color:#f92672">&lt;</span>Shader<span style="color:#f92672">&gt;</span>(key);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (resource_ptr <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> resource_ptr;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    resource_ptr <span style="color:#f92672">=</span> ShaderFactory<span style="color:#f92672">::</span>create(vertex_path, pixel_path);
</span></span><span style="display:flex;"><span>    m_shaders.emplace_back(resource_ptr);
</span></span><span style="display:flex;"><span>    names_to_shaders.insert(std<span style="color:#f92672">::</span>make_pair(key, m_shaders.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> resource_ptr;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This is a <code>load_shader()</code> function for shader programs in which we specify just a vertex shader and a pixel (fragment) shader. Again, <strong>shader file A is different from shader file B</strong>. So we <strong>generate a key</strong> of this shader asset <strong>from the paths of vertex and pixel shader</strong>!</p>
<p>We declare a stringstream and fill it with <code>vertex_path</code> and <code>pixel_path</code>. Then we use <code>generate_key()</code> method that will convert the stringstream to string and return it:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>string ResourceManager<span style="color:#f92672">::</span>generate_key(std<span style="color:#f92672">::</span>stringstream <span style="color:#66d9ef">const</span><span style="color:#f92672">&amp;</span> stream) <span style="color:#66d9ef">const</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> stream.str();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Then, in <code>load_shader()</code>, we obtain a resource from the respective vector (<code>auto resource_ptr = get_from_vector&lt;Shader&gt;(key);</code>) We tell what type of resource it is as a template parameter. And we will have either a proper resource (so we can return it and save memory, yay!) or we have a <code>nullptr</code> if nothing was found in the vector.</p>
<p>Look again what happens when no resource was found:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// (...)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>resource_ptr <span style="color:#f92672">=</span> ShaderFactory<span style="color:#f92672">::</span>create(vertex_path, pixel_path);
</span></span><span style="display:flex;"><span>m_shaders.emplace_back(resource_ptr);
</span></span><span style="display:flex;"><span>names_to_shaders.insert(std<span style="color:#f92672">::</span>make_pair(key, m_shaders.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">return</span> resource_ptr;
</span></span></code></pre></div><p><strong>When resource was not found in the vector, it needs to be loaded</strong>. And it might vary from resource to resource. Here we <strong>call a factory method</strong> that will <strong>load</strong> and create a valid shader program, <strong><code>emplace_back()</code> it into the vector</strong>, and <strong><code>insert()</code> a key-ID pair into the unordered map</strong>. From now on, the same resource (with this key) will no longer be loaded again, resource manager will just return already loaded asset from the vector. <code>ShaderFactory::create()</code> can be replaced with your method that&rsquo;s used for loading and compiling shaders, of course.</p>
<p>Let&rsquo;s see another example. Meshes can be either parts of some models (loaded using libraries such as <a href="https://github.com/syoyo/tinygltf">tinygltf</a> or <a href="https://github.com/assimp/assimp">Assimp</a>) or they can be generated from code (e.g. cubes and spheres). How to properly distinguish meshes to load them <strong>only</strong> when needed?</p>
<p>Here&rsquo;s the trick: we used <strong>a mesh ID within the model</strong>, and <strong>paths to all textures</strong> in addition to <strong>a model name</strong> to generate a key.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>Mesh<span style="color:#f92672">&gt;</span> ResourceManager<span style="color:#f92672">::</span>load_mesh(u32 <span style="color:#66d9ef">const</span> array_id, std<span style="color:#f92672">::</span>string <span style="color:#66d9ef">const</span><span style="color:#f92672">&amp;</span> model_name, std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Vertex<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">const</span><span style="color:#f92672">&amp;</span> vertices,
</span></span><span style="display:flex;"><span>                                                 std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>u32<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">const</span><span style="color:#f92672">&amp;</span> indices, std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>Texture<span style="color:#f92672">&gt;&gt;</span> <span style="color:#66d9ef">const</span><span style="color:#f92672">&amp;</span> textures,
</span></span><span style="display:flex;"><span>                                                 DrawType <span style="color:#66d9ef">const</span> draw_type, std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>Material<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">const</span><span style="color:#f92672">&amp;</span> material,
</span></span><span style="display:flex;"><span>                                                 DrawFunctionType <span style="color:#66d9ef">const</span> draw_function)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>stringstream stream;
</span></span><span style="display:flex;"><span>    stream <span style="color:#f92672">&lt;&lt;</span> model_name <span style="color:#f92672">&lt;&lt;</span> array_id;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> <span style="color:#66d9ef">const</span><span style="color:#f92672">&amp;</span> texture : textures)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        stream <span style="color:#f92672">&lt;&lt;</span> texture<span style="color:#f92672">-&gt;</span>path;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>string <span style="color:#66d9ef">const</span><span style="color:#f92672">&amp;</span> key <span style="color:#f92672">=</span> generate_key(stream);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> resource_ptr <span style="color:#f92672">=</span> get_from_vector<span style="color:#f92672">&lt;</span>Mesh<span style="color:#f92672">&gt;</span>(key);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (resource_ptr <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> resource_ptr;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    resource_ptr <span style="color:#f92672">=</span> MeshFactory<span style="color:#f92672">::</span>create(vertices, indices, textures, draw_type, material, draw_function);
</span></span><span style="display:flex;"><span>    m_meshes.emplace_back(resource_ptr);
</span></span><span style="display:flex;"><span>    names_to_meshes.insert(std<span style="color:#f92672">::</span>make_pair(key, m_meshes.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> resource_ptr;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Processing all meshes within one model, in a <code>Model</code> class, looks like this now:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// Model.cpp:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> Model<span style="color:#f92672">::</span>proccess_node(aiNode <span style="color:#66d9ef">const</span><span style="color:#f92672">*</span> node, aiScene <span style="color:#66d9ef">const</span><span style="color:#f92672">*</span> scene)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (u32 i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> node<span style="color:#f92672">-&gt;</span>mNumMeshes; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        aiMesh <span style="color:#66d9ef">const</span><span style="color:#f92672">*</span> mesh <span style="color:#f92672">=</span> scene<span style="color:#f92672">-&gt;</span>mMeshes[node<span style="color:#f92672">-&gt;</span>mMeshes[i]];
</span></span><span style="display:flex;"><span>        m_meshes.emplace_back(proccess_mesh(mesh, scene));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// (...)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>Mesh<span style="color:#f92672">&gt;</span> Model<span style="color:#f92672">::</span>proccess_mesh(aiMesh <span style="color:#66d9ef">const</span><span style="color:#f92672">*</span> mesh, aiScene <span style="color:#66d9ef">const</span><span style="color:#f92672">*</span> scene)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// (...)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// m_meshes is being filled, so m_meshes.size() gets incremented and it&#39;s unique each iteration
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> ResourceManager<span style="color:#f92672">::</span>get_instance().load_mesh(m_meshes.size(), model_path, vertices,
</span></span><span style="display:flex;"><span>                                                    indices, textures, m_draw_type, material); <span style="color:#75715e">// array_id for generating key is an index in m_meshes 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>Passing a size of <code>m_meshes</code> to <code>ResourceManager</code> when filling <code>m_meshes</code> to generate a key is smart and easy! But what if a mesh is generated, e.g. it&rsquo;s a simple code-generated cube or a quad? Take a look:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// &#34;Button&#34;, a class that needs to create a mesh from code. Button.cpp:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>Mesh<span style="color:#f92672">&gt;</span> Button<span style="color:#f92672">::</span>create_sprite() <span style="color:#66d9ef">const</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Vertex<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">const</span> vertices <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>        {glm<span style="color:#f92672">::</span>vec3(<span style="color:#f92672">-</span><span style="color:#ae81ff">1.0f</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1.0f</span>, <span style="color:#ae81ff">0.0f</span>), {}, {<span style="color:#ae81ff">0.0f</span>, <span style="color:#ae81ff">0.0f</span>}}, <span style="color:#75715e">// bottom left
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        {glm<span style="color:#f92672">::</span>vec3(<span style="color:#ae81ff">1.0f</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1.0f</span>, <span style="color:#ae81ff">0.0f</span>), {}, {<span style="color:#ae81ff">1.0f</span>, <span style="color:#ae81ff">0.0f</span>}}, <span style="color:#75715e">// bottom right
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        {glm<span style="color:#f92672">::</span>vec3(<span style="color:#ae81ff">1.0f</span>, <span style="color:#ae81ff">1.0f</span>, <span style="color:#ae81ff">0.0f</span>), {}, {<span style="color:#ae81ff">1.0f</span>, <span style="color:#ae81ff">1.0f</span>}}, <span style="color:#75715e">// top right
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        {glm<span style="color:#f92672">::</span>vec3(<span style="color:#f92672">-</span><span style="color:#ae81ff">1.0f</span>, <span style="color:#ae81ff">1.0f</span>, <span style="color:#ae81ff">0.0f</span>), {}, {<span style="color:#ae81ff">0.0f</span>, <span style="color:#ae81ff">1.0f</span>}}, <span style="color:#75715e">// top left
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>u32<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">const</span> indices <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>Texture<span style="color:#f92672">&gt;&gt;</span> textures;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>Texture<span style="color:#f92672">&gt;&gt;</span> diffuse_maps <span style="color:#f92672">=</span> {};
</span></span><span style="display:flex;"><span>    TextureSettings texture_settings <span style="color:#f92672">=</span> {};
</span></span><span style="display:flex;"><span>    texture_settings.wrap_mode_x <span style="color:#f92672">=</span> TextureWrapMode<span style="color:#f92672">::</span>ClampToEdge;
</span></span><span style="display:flex;"><span>    texture_settings.wrap_mode_y <span style="color:#f92672">=</span> TextureWrapMode<span style="color:#f92672">::</span>ClampToEdge;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>m_texture_path.empty())
</span></span><span style="display:flex;"><span>        diffuse_maps.emplace_back(ResourceManager<span style="color:#f92672">::</span>get_instance().load_texture(m_texture_path, TextureType<span style="color:#f92672">::</span>Diffuse, texture_settings));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    textures.insert(textures.end(), diffuse_maps.begin(), diffuse_maps.end());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ResourceManager<span style="color:#f92672">::</span>get_instance().load_mesh(<span style="color:#ae81ff">0</span>, m_texture_path, vertices, indices, textures, DrawType<span style="color:#f92672">::</span>Triangles, material);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>You can see two usages of <code>ResourceManager</code> here. The first one is for a texture, and the second one is for handling a code-generated quad. In this case, <strong>we only need info about the texture for the quad to uniquely identify it</strong>. So we simply pass &ldquo;0&rdquo; as an <code>array_id</code>, because there&rsquo;s no mesh array in <code>Button</code> class, it&rsquo;s just one mesh with four vertices declared by hand.</p>
<p>In more complex cases you might need to come up with more sophisticated ways of generating keys to identify the assets.</p>
<h2 id="summary">Summary</h2>
<p>That&rsquo;s it! I hope now you can be happy with your saved memory, smaller CPU usage, and shorter loading times. 😄 Even if the performance of your engine was improved just by a little, this was <strong>an important step in building a sensible engine architecture.</strong> And <strong>you will thank yourself for writing runtime resource manager</strong> when you will approach programming systems that <strong>load plenty of entities</strong>, such as <strong>particle systems</strong>. Here&rsquo;s a recap of the post:</p>



  



<div class="notice tip summary">
  <div class="notice-head"><svg
        width="20"
        height="20"
        viewBox="0 0 20 20"
        fill="none"
        xmlns="http://www.w3.org/2000/svg">
        <path
          d="M10 9V14M10 19C5.02944 19 1 14.9706 1 10C1 5.02944 5.02944 1 10 1C14.9706 1 19 5.02944 19 10C19 14.9706 14.9706 19 10 19ZM10.0498 6V6.1L9.9502 6.1002V6H10.0498Z"
          stroke="currentColor"
          stroke-width="2"
          stroke-linecap="round"
          stroke-linejoin="round"></path>
      </svg><p>Tip Summary</p>
  </div>
  <div class="notice-body"><p><p>How basic runtime resource manager works when you request (load) a resource:</p>
<ul>
<li><strong>it generates a key</strong> (each loading function may have slightly different implementation).</li>
<li><strong>calls a template method <code>get_from_vector()</code></strong> specifying desired resource type and providing the key. It will return either <code>nullptr</code> or a valid resource.
<ul>
<li>if a <strong>valid resource</strong> is returned by <code>get_from_vector()</code>, <strong>you&rsquo;ve got your resource</strong>!</li>
<li>if a <code>nullptr</code> is returned by <code>get_from_vector()</code>, a custom loading function (e.g. from a <code>ShaderLoader</code>) is called and the <strong>returned value is added to a vector</strong>. A <strong>key and ID</strong> pair is added to an unordered map. The freshly loaded resource is returned.</li>
</ul>
</li>
</ul></p></div>
</div>

<h2 id="what-you-need-to-be-aware-of">What You Need to Be Aware of</h2>
<p>As mentioned earlier, this engine was developed in <strong>a single semester</strong> by <strong>4 students</strong>, using the tools and techniques we were familiar with, <strong>primarily modern C++</strong>. Our goal was to create something functional and <strong>beginner-friendly</strong>, working within the constraints of our time and experience. We had just <strong>4 months</strong> to build both the engine and <a href="/portfolio/guiding-light/"><strong>create a game on it</strong></a> with the rest of the team. We know that <strong>engine programming is a vast field</strong> and <strong>our approach might sometimes differ from what you&rsquo;d see in AAA studios</strong>. Nevertheless, this was a solid first step and we’re proud of it. Special thanks to:</p>
<ul>
<li><a href="https://www.linkedin.com/in/mariusz-sielicki/">Mariusz Sielicki</a>, an experienced developer who has guided me and my team through struggles with resource management and broadened my grasp of how vast this topic is.</li>
<li>Activision, for <a href="https://youtu.be/e_SSo7u1r_w?t=17490">appreciating our project and awarding it</a> at ZTGK 2024 Gamedev Contest.</li>
</ul>
<h2 id="sources--additional-materials">Sources &amp; Additional Materials</h2>
<ul>
<li><a href="https://www.amazon.com/Engine-Architecture-Third-Jason-Gregory/dp/1138035459">Game Engine Architecture, 3rd Edition</a> – a Bible of engine programming, serving as a great introductory text. Has a solid chapter on resource management. Great!</li>
<li><a href="https://www.gamedev.net/tutorials/_/technical/game-programming/a-resource-manager-for-game-assets-r3807/">A Resource Manager for Game Assets</a> – a similar article on gamedev.net, showing a similar approach with a use of an unordered map.</li>
</ul>
]]></description>
                

                <guid isPermaLink="false">tag:mikegalinski.com,2024-10-04:/blog/post-3/</guid>

                
                    <link>https://mikegalinski.com/blog/post-3/</link>
                

                
                    <pubDate>Fri, 04 Oct 2024 16:58:35 CEST</pubDate>
                

                
                    <title>Basic Resource Management in a Custom Game Engine</title>
                
            </item>
        
    </channel>
</rss>
